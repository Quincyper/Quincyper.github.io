{"meta":{"title":"Quincyper","subtitle":"","description":"此生逍遥君子意 一壶温酒向长空","author":"系小鹏鹏吖","url":"http://quincyper.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-02-27T09:28:27.762Z","updated":"2020-02-27T09:28:27.758Z","comments":true,"path":"404.html","permalink":"http://quincyper.github.io/404.html","excerpt":"","text":"404 �ܱ�Ǹ�������ʵ�ҳ�治���� �����������ַ�����õ�ַ�ѱ�ɾ��"},{"title":"关于","date":"2020-04-29T16:49:01.600Z","updated":"2020-04-29T16:47:43.705Z","comments":true,"path":"index.html","permalink":"http://quincyper.github.io/index.html","excerpt":"","text":""},{"title":"","date":"2020-04-29T17:00:07.219Z","updated":"2020-04-29T17:00:07.219Z","comments":true,"path":"about/index.html","permalink":"http://quincyper.github.io/about/index.html","excerpt":"","text":"江湖名称：鹏少 常驻之地：中国 | 广西 | 桂林 初度之辰：1999 兴趣爱好：骑游 | 编程 | 剪辑 技能 | Skill HTML/CSS/JS 65% C/C++ 20% JAVA 30% PYTHON 75% HEXO/GIT 90% PS/PR/AE 65% 简介 | Introduction ● 学历：在校本科通信工程大三学生； ● 现况：自学Python中，网络爬虫方向； ● 目标：优秀前端 or 网络爬虫工程师； ● 博客：好记性不如烂笔头，记录学习过程； ● 兴趣：吃喝拉撒 ● 其他：虽然很菜，但是在努力学习中！ if ('addEventListener' in window) { window.addEventListener('load', function () { document.body.className = document.body.className.replace(/\\bis-loading\\b/, ''); }); document.body.className += (navigator.userAgent.match(/(MSIE|rv:11\\.0)/) ? ' is-ie' : ''); } uniform mat4 uProjection; uniform mat4 uModelview; uniform vec3 uResolution; uniform vec3 uOffset; uniform vec3 uDOF; //x:focus distance, y:focus radius, z:max radius uniform vec3 uFade; //x:start distance, y:half distance, z:near fade start attribute vec3 aPosition; attribute vec3 aEuler; attribute vec2 aMisc; //x:size, y:fade varying vec3 pposition; varying float psize; varying float palpha; varying float pdist; //varying mat3 rotMat; varying vec3 normX; varying vec3 normY; varying vec3 normZ; varying vec3 normal; varying float diffuse; varying float specular; varying float rstop; varying float distancefade; void main(void) { // Projection is based on vertical angle vec4 pos = uModelview * vec4(aPosition + uOffset, 1.0); gl_Position = uProjection * pos; gl_PointSize = aMisc.x * uProjection[1][1] / -pos.z * uResolution.y * 0.5; pposition = pos.xyz; psize = aMisc.x; pdist = length(pos.xyz); palpha = smoothstep(0.0, 1.0, (pdist - 0.1) / uFade.z); vec3 elrsn = sin(aEuler); vec3 elrcs = cos(aEuler); mat3 rotx = mat3( 1.0, 0.0, 0.0, 0.0, elrcs.x, elrsn.x, 0.0, -elrsn.x, elrcs.x ); mat3 roty = mat3( elrcs.y, 0.0, -elrsn.y, 0.0, 1.0, 0.0, elrsn.y, 0.0, elrcs.y ); mat3 rotz = mat3( elrcs.z, elrsn.z, 0.0, -elrsn.z, elrcs.z, 0.0, 0.0, 0.0, 1.0 ); mat3 rotmat = rotx * roty * rotz; normal = rotmat[2]; mat3 trrotm = mat3( rotmat[0][0], rotmat[1][0], rotmat[2][0], rotmat[0][1], rotmat[1][1], rotmat[2][1], rotmat[0][2], rotmat[1][2], rotmat[2][2] ); normX = trrotm[0]; normY = trrotm[1]; normZ = trrotm[2]; const vec3 lit = vec3(0.6917144638660746, 0.6917144638660746, -0.20751433915982237); float tmpdfs = dot(lit, normal); if(tmpdfs < 0.0) { normal = -normal; tmpdfs = dot(lit, normal); } diffuse = 0.4 + tmpdfs; vec3 eyev = normalize(-pos.xyz); if(dot(eyev, normal) > 0.0) { vec3 hv = normalize(eyev + lit); specular = pow(max(dot(hv, normal), 0.0), 20.0); } else { specular = 0.0; } rstop = clamp((abs(pdist - uDOF.x) - uDOF.y) / uDOF.z, 0.0, 1.0); rstop = pow(rstop, 0.5); //-0.69315 = ln(0.5) distancefade = min(1.0, exp((uFade.x - pdist) * 0.69315 / uFade.y)); } #ifdef GL_ES //precision mediump float; precision highp float; #endif uniform vec3 uDOF; //x:focus distance, y:focus radius, z:max radius uniform vec3 uFade; //x:start distance, y:half distance, z:near fade start const vec3 fadeCol = vec3(0.08, 0.03, 0.06); varying vec3 pposition; varying float psize; varying float palpha; varying float pdist; //varying mat3 rotMat; varying vec3 normX; varying vec3 normY; varying vec3 normZ; varying vec3 normal; varying float diffuse; varying float specular; varying float rstop; varying float distancefade; float ellipse(vec2 p, vec2 o, vec2 r) { vec2 lp = (p - o) / r; return length(lp) - 1.0; } void main(void) { vec3 p = vec3(gl_PointCoord - vec2(0.5, 0.5), 0.0) * 2.0; vec3 d = vec3(0.0, 0.0, -1.0); float nd = normZ.z; //dot(-normZ, d); if(abs(nd) < 0.0001) discard; float np = dot(normZ, p); vec3 tp = p + d * np / nd; vec2 coord = vec2(dot(normX, tp), dot(normY, tp)); //angle = 15 degree const float flwrsn = 0.258819045102521; const float flwrcs = 0.965925826289068; mat2 flwrm = mat2(flwrcs, -flwrsn, flwrsn, flwrcs); vec2 flwrp = vec2(abs(coord.x), coord.y) * flwrm; float r; if(flwrp.x < 0.0) { r = ellipse(flwrp, vec2(0.065, 0.024) * 0.5, vec2(0.36, 0.96) * 0.5); } else { r = ellipse(flwrp, vec2(0.065, 0.024) * 0.5, vec2(0.58, 0.96) * 0.5); } if(r > rstop) discard; vec3 col = mix(vec3(1.0, 0.8, 0.75), vec3(1.0, 0.9, 0.87), r); float grady = mix(0.0, 1.0, pow(coord.y * 0.5 + 0.5, 0.35)); col *= vec3(1.0, grady, grady); col *= mix(0.8, 1.0, pow(abs(coord.x), 0.3)); col = col * diffuse + specular; col = mix(fadeCol, col, distancefade); float alpha = (rstop > 0.001)? (0.5 - r / (rstop * 2.0)) : 1.0; alpha = smoothstep(0.0, 1.0, alpha) * palpha; gl_FragColor = vec4(col * 0.5, alpha); } uniform vec3 uResolution; attribute vec2 aPosition; varying vec2 texCoord; varying vec2 screenCoord; void main(void) { gl_Position = vec4(aPosition, 0.0, 1.0); texCoord = aPosition.xy * 0.5 + vec2(0.5, 0.5); screenCoord = aPosition.xy * vec2(uResolution.z, 1.0); } #ifdef GL_ES //precision mediump float; precision highp float; #endif uniform vec2 uTimes; varying vec2 texCoord; varying vec2 screenCoord; void main(void) { vec3 col; float c; vec2 tmpv = texCoord * vec2(0.8, 1.0) - vec2(0.95, 1.0); c = exp(-pow(length(tmpv) * 1.8, 2.0)); col = mix(vec3(0.02, 0.0, 0.03), vec3(0.96, 0.98, 1.0) * 1.5, c); gl_FragColor = vec4(col * 0.5, 1.0); } #ifdef GL_ES //precision mediump float; precision highp float; #endif uniform sampler2D uSrc; uniform vec2 uDelta; varying vec2 texCoord; varying vec2 screenCoord; void main(void) { vec4 col = texture2D(uSrc, texCoord); gl_FragColor = vec4(col.rgb * 2.0 - vec3(0.5), 1.0); } #ifdef GL_ES //precision mediump float; precision highp float; #endif uniform sampler2D uSrc; uniform vec2 uDelta; uniform vec4 uBlurDir; //dir(x, y), stride(z, w) varying vec2 texCoord; varying vec2 screenCoord; void main(void) { vec4 col = texture2D(uSrc, texCoord); col = col + texture2D(uSrc, texCoord + uBlurDir.xy * uDelta); col = col + texture2D(uSrc, texCoord - uBlurDir.xy * uDelta); col = col + texture2D(uSrc, texCoord + (uBlurDir.xy + uBlurDir.zw) * uDelta); col = col + texture2D(uSrc, texCoord - (uBlurDir.xy + uBlurDir.zw) * uDelta); gl_FragColor = col / 5.0; } #ifdef GL_ES //precision mediump float; precision highp float; #endif uniform sampler2D uSrc; uniform vec2 uDelta; varying vec2 texCoord; varying vec2 screenCoord; void main(void) { gl_FragColor = texture2D(uSrc, texCoord); } uniform vec3 uResolution; attribute vec2 aPosition; varying vec2 texCoord; varying vec2 screenCoord; void main(void) { gl_Position = vec4(aPosition, 0.0, 1.0); texCoord = aPosition.xy * 0.5 + vec2(0.5, 0.5); screenCoord = aPosition.xy * vec2(uResolution.z, 1.0); } #ifdef GL_ES //precision mediump float; precision highp float; #endif uniform sampler2D uSrc; uniform sampler2D uBloom; uniform vec2 uDelta; varying vec2 texCoord; varying vec2 screenCoord; void main(void) { vec4 srccol = texture2D(uSrc, texCoord) * 2.0; vec4 bloomcol = texture2D(uBloom, texCoord); vec4 col; col = srccol + bloomcol * (vec4(1.0) + srccol); col *= smoothstep(1.0, 0.0, pow(length((texCoord - vec2(0.5)) * 2.0), 1.2) * 0.5); col = pow(col, vec4(0.45454545454545)); //(1.0 / 2.2) gl_FragColor = vec4(col.rgb, 1.0); gl_FragColor.a = 1.0; } L2Dwidget.init({\"model\":{\"jsonPath\":\"/live2dw/assets/z16.model.json\"},\"display\":{\"position\":\"left\",\"width\":140,\"height\":240},\"mobile\":{\"show\":true},\"log\":false,\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"pluginRootPath\":\"live2dw/\",\"tagMode\":false});"},{"title":"分类","date":"2019-12-16T10:57:35.000Z","updated":"2020-04-29T03:54:45.304Z","comments":true,"path":"categories/index.html","permalink":"http://quincyper.github.io/categories/index.html","excerpt":"","text":"testubuntu"},{"title":"所有标签","date":"2019-12-14T14:20:36.000Z","updated":"2020-04-29T16:46:47.498Z","comments":false,"path":"tags/index.html","permalink":"http://quincyper.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-04-29T09:31:25.230Z","updated":"2020-02-16T13:52:06.000Z","comments":true,"path":"about/about.css","permalink":"http://quincyper.github.io/about/about.css","excerpt":"","text":"body { margin: 0; overflow-x: hidden; overflow-y: hidden; } .mdui-container, .mdui-container-fluid { box-sizing: border-box; padding-right: 8px; padding-left: 8px; margin-right: auto; margin-left: auto } .mdui-container-fluid:after, .mdui-container:after { display: table; clear: both; content: '' } .mdui-container { width: 96%; max-width: 1280px } @media (min-width:600px) { .mdui-container { width: 94% } } @media (min-width:1024px) { .mdui-container { width: 92% } } h3 { text-align: center } .icon { padding: 0 2% 1% 2%; width: 40px; height: 40px } table { text-align: left; font-family:'STZhongsong'; margin: 0 0 0 230px; font-size: 20px; height: 145px; width: 75% } .showarea-1 { opacity: 0.9; background-color: white; margin: 4% 10% 0% 10%; padding: 10px } .showarea-2 { opacity: 0.9; background-color: white; height: 300px; margin: 0.5% 0 0 10%; float: left; width: 38%; padding: 0 0 8px 20px } .showarea-3 { opacity: 0.9; background-color: white; height: 300px; float: left; width: 38.3%; margin: 0.5% 0 0 0.5%; padding: 0 0 8px 20px } .showarea-4 { opacity: 0.9; background-color: white; margin: 0.5% 10% 0 10%; padding: 8px; text-align: center } .skill { max-width: 700px; margin: auto; } .skill .item { width: 100%; clear: both; margin-right: auto; margin-left: auto; height: 35px; } .skill .describe { font-family: \"Microsoft Yahei\"; margin-right: 12px; text-align: center; } .skill .progress { float: left; height: 25px; background: #fbfbfb; border-left: 1px solid transparent; border-right: 1px solid transparent; width: 70%; } .skill .progress>span { position: relative; float: left; margin: 0 -1px; min-width: 30px; height: 25px; line-height: 21px; text-align: right; background: #cccccc; border: none; border-color: #bfbfbf #b3b3b3 #9e9e9e; box-shadow: inset 0 1px rgba(255, 255, 255, 0.3), 0 1px 2px rgba(0, 0, 0, 0.2); } .skill .progress>span>span { padding: 0 8px; font-size: 14px; color: #404040; color: rgba(0, 0, 0, 0.7); font-family: \"Microsoft Yahie\"; line-height: 25px; } .skill .progress>span:before { content: ''; position: absolute; top: 0; bottom: 0; left: 0; right: 0; z-index: 1; height: 25px; border-radius: 10px; } .skill .progress .green { background: #49C085; } .skill .progress .darkblue { background: #7782D1; } .skill .progress .red { background: #EC5B5B; } .skill .progress .orange { background: #f2b63c; } .skill .progress .blue { background: #6F92FF; } @media (min-width:750px) { .skill .describe { width: 100px; float: left; } .skill .progress { width: 70%; float: left; } } @media (max-width:750px) { .skill .describe { width: 100%; margin-bottom: 5px; text-align: left; } .skill .progress { width: 100%; margin-bottom: 5px; } } #mainicon { -webkit-animation: rotateImg 5s linear infinite; height: 140px; width: 140px; float: left; border: 3px solid; border-color: aqua; border-radius: 50%; transition: -webkit-transform 1s; transition: transform 1s; transition: transform 1s, -webkit-transform 1s; max-width: 50%; display: block } @keyframes rotateImg { 0% { -webkit-transform: rotate(0deg); transform: rotate(0deg); } 100% { -webkit-transform: rotate(360deg); transform: rotate(360deg); } } @-webkit-keyframes rotateImg { 0% { -webkit-transform: rotate(0deg); } 100% { -webkit-transform: rotate(360deg); } } canvas { top: 0; padding: 0; margin: 0; position: absolute; z-index: -1; left: 0px } #footer { position: relative; clear: both; width: 100%; top: 20px; text-align: center; display: inline-block; color: #D3D3D3; font-family:Georgia, 'Times New Roman', Times, serif } #footer a { text-decoration: none; color: #D3D3D3; cursor: pointer } #footer a:hover { border-bottom: 1px dotted #FFFFFF; color: #FFFFFF } @media screen and (max-width:480px) { #mainicon { position: relative; float: top; display: block } }"},{"title":"","date":"2020-04-29T09:31:25.361Z","updated":"2020-02-16T13:52:06.000Z","comments":true,"path":"about/sakura.js","permalink":"http://quincyper.github.io/about/sakura.js","excerpt":"","text":"// Utilities var Vector3 = {}; var Matrix44 = {}; Vector3.create = function(x, y, z) { return {'x':x, 'y':y, 'z':z}; }; Vector3.dot = function (v0, v1) { return v0.x * v1.x + v0.y * v1.y + v0.z * v1.z; }; Vector3.cross = function (v, v0, v1) { v.x = v0.y * v1.z - v0.z * v1.y; v.y = v0.z * v1.x - v0.x * v1.z; v.z = v0.x * v1.y - v0.y * v1.x; }; Vector3.normalize = function (v) { var l = v.x * v.x + v.y * v.y + v.z * v.z; if(l > 0.00001) { l = 1.0 / Math.sqrt(l); v.x *= l; v.y *= l; v.z *= l; } }; Vector3.arrayForm = function(v) { if(v.array) { v.array[0] = v.x; v.array[1] = v.y; v.array[2] = v.z; } else { v.array = new Float32Array([v.x, v.y, v.z]); } return v.array; }; Matrix44.createIdentity = function () { return new Float32Array([1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0]); }; Matrix44.loadProjection = function (m, aspect, vdeg, near, far) { var h = near * Math.tan(vdeg * Math.PI / 180.0 * 0.5) * 2.0; var w = h * aspect; m[0] = 2.0 * near / w; m[1] = 0.0; m[2] = 0.0; m[3] = 0.0; m[4] = 0.0; m[5] = 2.0 * near / h; m[6] = 0.0; m[7] = 0.0; m[8] = 0.0; m[9] = 0.0; m[10] = -(far + near) / (far - near); m[11] = -1.0; m[12] = 0.0; m[13] = 0.0; m[14] = -2.0 * far * near / (far - near); m[15] = 0.0; }; Matrix44.loadLookAt = function (m, vpos, vlook, vup) { var frontv = Vector3.create(vpos.x - vlook.x, vpos.y - vlook.y, vpos.z - vlook.z); Vector3.normalize(frontv); var sidev = Vector3.create(1.0, 0.0, 0.0); Vector3.cross(sidev, vup, frontv); Vector3.normalize(sidev); var topv = Vector3.create(1.0, 0.0, 0.0); Vector3.cross(topv, frontv, sidev); Vector3.normalize(topv); m[0] = sidev.x; m[1] = topv.x; m[2] = frontv.x; m[3] = 0.0; m[4] = sidev.y; m[5] = topv.y; m[6] = frontv.y; m[7] = 0.0; m[8] = sidev.z; m[9] = topv.z; m[10] = frontv.z; m[11] = 0.0; m[12] = -(vpos.x * m[0] + vpos.y * m[4] + vpos.z * m[8]); m[13] = -(vpos.x * m[1] + vpos.y * m[5] + vpos.z * m[9]); m[14] = -(vpos.x * m[2] + vpos.y * m[6] + vpos.z * m[10]); m[15] = 1.0; }; // var timeInfo = { 'start':0, 'prev':0, // Date 'delta':0, 'elapsed':0 // Number(sec) }; // var gl; var renderSpec = { 'width':0, 'height':0, 'aspect':1, 'array':new Float32Array(3), 'halfWidth':0, 'halfHeight':0, 'halfArray':new Float32Array(3) // and some render targets. see setViewport() }; renderSpec.setSize = function(w, h) { renderSpec.width = w; renderSpec.height = h; renderSpec.aspect = renderSpec.width / renderSpec.height; renderSpec.array[0] = renderSpec.width; renderSpec.array[1] = renderSpec.height; renderSpec.array[2] = renderSpec.aspect; renderSpec.halfWidth = Math.floor(w / 2); renderSpec.halfHeight = Math.floor(h / 2); renderSpec.halfArray[0] = renderSpec.halfWidth; renderSpec.halfArray[1] = renderSpec.halfHeight; renderSpec.halfArray[2] = renderSpec.halfWidth / renderSpec.halfHeight; }; function deleteRenderTarget(rt) { gl.deleteFramebuffer(rt.frameBuffer); gl.deleteRenderbuffer(rt.renderBuffer); gl.deleteTexture(rt.texture); } function createRenderTarget(w, h) { var ret = { 'width':w, 'height':h, 'sizeArray':new Float32Array([w, h, w / h]), 'dtxArray':new Float32Array([1.0 / w, 1.0 / h]) }; ret.frameBuffer = gl.createFramebuffer(); ret.renderBuffer = gl.createRenderbuffer(); ret.texture = gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D, ret.texture); gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR); gl.bindFramebuffer(gl.FRAMEBUFFER, ret.frameBuffer); gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, ret.texture, 0); gl.bindRenderbuffer(gl.RENDERBUFFER, ret.renderBuffer); gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, w, h); gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, ret.renderBuffer); gl.bindTexture(gl.TEXTURE_2D, null); gl.bindRenderbuffer(gl.RENDERBUFFER, null); gl.bindFramebuffer(gl.FRAMEBUFFER, null); return ret; } function compileShader(shtype, shsrc) { var retsh = gl.createShader(shtype); gl.shaderSource(retsh, shsrc); gl.compileShader(retsh); if(!gl.getShaderParameter(retsh, gl.COMPILE_STATUS)) { var errlog = gl.getShaderInfoLog(retsh); gl.deleteShader(retsh); console.error(errlog); return null; } return retsh; } function createShader(vtxsrc, frgsrc, uniformlist, attrlist) { var vsh = compileShader(gl.VERTEX_SHADER, vtxsrc); var fsh = compileShader(gl.FRAGMENT_SHADER, frgsrc); if(vsh == null || fsh == null) { return null; } var prog = gl.createProgram(); gl.attachShader(prog, vsh); gl.attachShader(prog, fsh); gl.deleteShader(vsh); gl.deleteShader(fsh); gl.linkProgram(prog); if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) { var errlog = gl.getProgramInfoLog(prog); console.error(errlog); return null; } if(uniformlist) { prog.uniforms = {}; for(var i = 0; i < uniformlist.length; i++) { prog.uniforms[uniformlist[i]] = gl.getUniformLocation(prog, uniformlist[i]); } } if(attrlist) { prog.attributes = {}; for(var i = 0; i < attrlist.length; i++) { var attr = attrlist[i]; prog.attributes[attr] = gl.getAttribLocation(prog, attr); } } return prog; } function useShader(prog) { gl.useProgram(prog); for(var attr in prog.attributes) { gl.enableVertexAttribArray(prog.attributes[attr]);; } } function unuseShader(prog) { for(var attr in prog.attributes) { gl.disableVertexAttribArray(prog.attributes[attr]);; } gl.useProgram(null); } ///// var projection = { 'angle':60, 'nearfar':new Float32Array([0.1, 100.0]), 'matrix':Matrix44.createIdentity() }; var camera = { 'position':Vector3.create(0, 0, 100), 'lookat':Vector3.create(0, 0, 0), 'up':Vector3.create(0, 1, 0), 'dof':Vector3.create(10.0, 4.0, 8.0), 'matrix':Matrix44.createIdentity() }; var pointFlower = {}; var meshFlower = {}; var sceneStandBy = false; var BlossomParticle = function () { this.velocity = new Array(3); this.rotation = new Array(3); this.position = new Array(3); this.euler = new Array(3); this.size = 1.0; this.alpha = 1.0; this.zkey = 0.0; }; BlossomParticle.prototype.setVelocity = function (vx, vy, vz) { this.velocity[0] = vx; this.velocity[1] = vy; this.velocity[2] = vz; }; BlossomParticle.prototype.setRotation = function (rx, ry, rz) { this.rotation[0] = rx; this.rotation[1] = ry; this.rotation[2] = rz; }; BlossomParticle.prototype.setPosition = function (nx, ny, nz) { this.position[0] = nx; this.position[1] = ny; this.position[2] = nz; }; BlossomParticle.prototype.setEulerAngles = function (rx, ry, rz) { this.euler[0] = rx; this.euler[1] = ry; this.euler[2] = rz; }; BlossomParticle.prototype.setSize = function (s) { this.size = s; }; BlossomParticle.prototype.update = function (dt, et) { this.position[0] += this.velocity[0] * dt; this.position[1] += this.velocity[1] * dt; this.position[2] += this.velocity[2] * dt; this.euler[0] += this.rotation[0] * dt; this.euler[1] += this.rotation[1] * dt; this.euler[2] += this.rotation[2] * dt; }; function createPointFlowers() { // get point sizes var prm = gl.getParameter(gl.ALIASED_POINT_SIZE_RANGE); renderSpec.pointSize = {'min':prm[0], 'max':prm[1]}; var vtxsrc = document.getElementById(\"sakura_point_vsh\").textContent; var frgsrc = document.getElementById(\"sakura_point_fsh\").textContent; pointFlower.program = createShader( vtxsrc, frgsrc, ['uProjection', 'uModelview', 'uResolution', 'uOffset', 'uDOF', 'uFade'], ['aPosition', 'aEuler', 'aMisc'] ); useShader(pointFlower.program); pointFlower.offset = new Float32Array([0.0, 0.0, 0.0]); pointFlower.fader = Vector3.create(0.0, 10.0, 0.0); // paramerters: velocity[3], rotate[3] pointFlower.numFlowers = 1600; pointFlower.particles = new Array(pointFlower.numFlowers); // vertex attributes {position[3], euler_xyz[3], size[1]} pointFlower.dataArray = new Float32Array(pointFlower.numFlowers * (3 + 3 + 2)); pointFlower.positionArrayOffset = 0; pointFlower.eulerArrayOffset = pointFlower.numFlowers * 3; pointFlower.miscArrayOffset = pointFlower.numFlowers * 6; pointFlower.buffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, pointFlower.buffer); gl.bufferData(gl.ARRAY_BUFFER, pointFlower.dataArray, gl.DYNAMIC_DRAW); gl.bindBuffer(gl.ARRAY_BUFFER, null); unuseShader(pointFlower.program); for(var i = 0; i < pointFlower.numFlowers; i++) { pointFlower.particles[i] = new BlossomParticle(); } } function initPointFlowers() { //area pointFlower.area = Vector3.create(20.0, 20.0, 20.0); pointFlower.area.x = pointFlower.area.y * renderSpec.aspect; pointFlower.fader.x = 10.0; //env fade start pointFlower.fader.y = pointFlower.area.z; //env fade half pointFlower.fader.z = 0.1; //near fade start //particles var PI2 = Math.PI * 2.0; var tmpv3 = Vector3.create(0, 0, 0); var tmpv = 0; var symmetryrand = function() {return (Math.random() * 2.0 - 1.0);}; for(var i = 0; i < pointFlower.numFlowers; i++) { var tmpprtcl = pointFlower.particles[i]; //velocity tmpv3.x = symmetryrand() * 0.3 + 0.8; tmpv3.y = symmetryrand() * 0.2 - 1.0; tmpv3.z = symmetryrand() * 0.3 + 0.5; Vector3.normalize(tmpv3); tmpv = 2.0 + Math.random() * 1.0; tmpprtcl.setVelocity(tmpv3.x * tmpv, tmpv3.y * tmpv, tmpv3.z * tmpv); //rotation tmpprtcl.setRotation( symmetryrand() * PI2 * 0.5, symmetryrand() * PI2 * 0.5, symmetryrand() * PI2 * 0.5 ); //position tmpprtcl.setPosition( symmetryrand() * pointFlower.area.x, symmetryrand() * pointFlower.area.y, symmetryrand() * pointFlower.area.z ); //euler tmpprtcl.setEulerAngles( Math.random() * Math.PI * 2.0, Math.random() * Math.PI * 2.0, Math.random() * Math.PI * 2.0 ); //size tmpprtcl.setSize(0.9 + Math.random() * 0.1); } } function renderPointFlowers() { //update var PI2 = Math.PI * 2.0; var limit = [pointFlower.area.x, pointFlower.area.y, pointFlower.area.z]; var repeatPos = function (prt, cmp, limit) { if(Math.abs(prt.position[cmp]) - prt.size * 0.5 > limit) { //out of area if(prt.position[cmp] > 0) { prt.position[cmp] -= limit * 2.0; } else { prt.position[cmp] += limit * 2.0; } } }; var repeatEuler = function (prt, cmp) { prt.euler[cmp] = prt.euler[cmp] % PI2; if(prt.euler[cmp] < 0.0) { prt.euler[cmp] += PI2; } }; for(var i = 0; i < pointFlower.numFlowers; i++) { var prtcl = pointFlower.particles[i]; prtcl.update(timeInfo.delta, timeInfo.elapsed); repeatPos(prtcl, 0, pointFlower.area.x); repeatPos(prtcl, 1, pointFlower.area.y); repeatPos(prtcl, 2, pointFlower.area.z); repeatEuler(prtcl, 0); repeatEuler(prtcl, 1); repeatEuler(prtcl, 2); prtcl.alpha = 1.0;//(pointFlower.area.z - prtcl.position[2]) * 0.5; prtcl.zkey = (camera.matrix[2] * prtcl.position[0] + camera.matrix[6] * prtcl.position[1] + camera.matrix[10] * prtcl.position[2] + camera.matrix[14]); } // sort pointFlower.particles.sort(function(p0, p1){return p0.zkey - p1.zkey;}); // update data var ipos = pointFlower.positionArrayOffset; var ieuler = pointFlower.eulerArrayOffset; var imisc = pointFlower.miscArrayOffset; for(var i = 0; i < pointFlower.numFlowers; i++) { var prtcl = pointFlower.particles[i]; pointFlower.dataArray[ipos] = prtcl.position[0]; pointFlower.dataArray[ipos + 1] = prtcl.position[1]; pointFlower.dataArray[ipos + 2] = prtcl.position[2]; ipos += 3; pointFlower.dataArray[ieuler] = prtcl.euler[0]; pointFlower.dataArray[ieuler + 1] = prtcl.euler[1]; pointFlower.dataArray[ieuler + 2] = prtcl.euler[2]; ieuler += 3; pointFlower.dataArray[imisc] = prtcl.size; pointFlower.dataArray[imisc + 1] = prtcl.alpha; imisc += 2; } //draw gl.enable(gl.BLEND); //gl.disable(gl.DEPTH_TEST); gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA); var prog = pointFlower.program; useShader(prog); gl.uniformMatrix4fv(prog.uniforms.uProjection, false, projection.matrix); gl.uniformMatrix4fv(prog.uniforms.uModelview, false, camera.matrix); gl.uniform3fv(prog.uniforms.uResolution, renderSpec.array); gl.uniform3fv(prog.uniforms.uDOF, Vector3.arrayForm(camera.dof)); gl.uniform3fv(prog.uniforms.uFade, Vector3.arrayForm(pointFlower.fader)); gl.bindBuffer(gl.ARRAY_BUFFER, pointFlower.buffer); gl.bufferData(gl.ARRAY_BUFFER, pointFlower.dataArray, gl.DYNAMIC_DRAW); gl.vertexAttribPointer(prog.attributes.aPosition, 3, gl.FLOAT, false, 0, pointFlower.positionArrayOffset * Float32Array.BYTES_PER_ELEMENT); gl.vertexAttribPointer(prog.attributes.aEuler, 3, gl.FLOAT, false, 0, pointFlower.eulerArrayOffset * Float32Array.BYTES_PER_ELEMENT); gl.vertexAttribPointer(prog.attributes.aMisc, 2, gl.FLOAT, false, 0, pointFlower.miscArrayOffset * Float32Array.BYTES_PER_ELEMENT); // doubler for(var i = 1; i < 2; i++) { var zpos = i * -2.0; pointFlower.offset[0] = pointFlower.area.x * -1.0; pointFlower.offset[1] = pointFlower.area.y * -1.0; pointFlower.offset[2] = pointFlower.area.z * zpos; gl.uniform3fv(prog.uniforms.uOffset, pointFlower.offset); gl.drawArrays(gl.POINT, 0, pointFlower.numFlowers); pointFlower.offset[0] = pointFlower.area.x * -1.0; pointFlower.offset[1] = pointFlower.area.y * 1.0; pointFlower.offset[2] = pointFlower.area.z * zpos; gl.uniform3fv(prog.uniforms.uOffset, pointFlower.offset); gl.drawArrays(gl.POINT, 0, pointFlower.numFlowers); pointFlower.offset[0] = pointFlower.area.x * 1.0; pointFlower.offset[1] = pointFlower.area.y * -1.0; pointFlower.offset[2] = pointFlower.area.z * zpos; gl.uniform3fv(prog.uniforms.uOffset, pointFlower.offset); gl.drawArrays(gl.POINT, 0, pointFlower.numFlowers); pointFlower.offset[0] = pointFlower.area.x * 1.0; pointFlower.offset[1] = pointFlower.area.y * 1.0; pointFlower.offset[2] = pointFlower.area.z * zpos; gl.uniform3fv(prog.uniforms.uOffset, pointFlower.offset); gl.drawArrays(gl.POINT, 0, pointFlower.numFlowers); } //main pointFlower.offset[0] = 0.0; pointFlower.offset[1] = 0.0; pointFlower.offset[2] = 0.0; gl.uniform3fv(prog.uniforms.uOffset, pointFlower.offset); gl.drawArrays(gl.POINT, 0, pointFlower.numFlowers); gl.bindBuffer(gl.ARRAY_BUFFER, null); unuseShader(prog); gl.enable(gl.DEPTH_TEST); gl.disable(gl.BLEND); } // effects //common util function createEffectProgram(vtxsrc, frgsrc, exunifs, exattrs) { var ret = {}; var unifs = ['uResolution', 'uSrc', 'uDelta']; if(exunifs) { unifs = unifs.concat(exunifs); } var attrs = ['aPosition']; if(exattrs) { attrs = attrs.concat(exattrs); } ret.program = createShader(vtxsrc, frgsrc, unifs, attrs); useShader(ret.program); ret.dataArray = new Float32Array([ -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0 ]); ret.buffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, ret.buffer); gl.bufferData(gl.ARRAY_BUFFER, ret.dataArray, gl.STATIC_DRAW); gl.bindBuffer(gl.ARRAY_BUFFER, null); unuseShader(ret.program); return ret; } // basic usage // useEffect(prog, srctex({'texture':texid, 'dtxArray':(f32)[dtx, dty]})); //basic initialize // gl.uniform**(...); //additional uniforms // drawEffect() // unuseEffect(prog) // TEXTURE0 makes src function useEffect(fxobj, srctex) { var prog = fxobj.program; useShader(prog); gl.uniform3fv(prog.uniforms.uResolution, renderSpec.array); if(srctex != null) { gl.uniform2fv(prog.uniforms.uDelta, srctex.dtxArray); gl.uniform1i(prog.uniforms.uSrc, 0); gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, srctex.texture); } } function drawEffect(fxobj) { gl.bindBuffer(gl.ARRAY_BUFFER, fxobj.buffer); gl.vertexAttribPointer(fxobj.program.attributes.aPosition, 2, gl.FLOAT, false, 0, 0); gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4); } function unuseEffect(fxobj) { unuseShader(fxobj.program); } var effectLib = {}; function createEffectLib() { var vtxsrc, frgsrc; //common var cmnvtxsrc = document.getElementById(\"fx_common_vsh\").textContent; //background frgsrc = document.getElementById(\"bg_fsh\").textContent; effectLib.sceneBg = createEffectProgram(cmnvtxsrc, frgsrc, ['uTimes'], null); // make brightpixels buffer frgsrc = document.getElementById(\"fx_brightbuf_fsh\").textContent; effectLib.mkBrightBuf = createEffectProgram(cmnvtxsrc, frgsrc, null, null); // direction blur frgsrc = document.getElementById(\"fx_dirblur_r4_fsh\").textContent; effectLib.dirBlur = createEffectProgram(cmnvtxsrc, frgsrc, ['uBlurDir'], null); //final composite vtxsrc = document.getElementById(\"pp_final_vsh\").textContent; frgsrc = document.getElementById(\"pp_final_fsh\").textContent; effectLib.finalComp = createEffectProgram(vtxsrc, frgsrc, ['uBloom'], null); } // background function createBackground() { //console.log(\"create background\"); } function initBackground() { //console.log(\"init background\"); } function renderBackground() { gl.disable(gl.DEPTH_TEST); useEffect(effectLib.sceneBg, null); gl.uniform2f(effectLib.sceneBg.program.uniforms.uTimes, timeInfo.elapsed, timeInfo.delta); drawEffect(effectLib.sceneBg); unuseEffect(effectLib.sceneBg); gl.enable(gl.DEPTH_TEST); } // post process var postProcess = {}; function createPostProcess() { //console.log(\"create post process\"); } function initPostProcess() { //console.log(\"init post process\"); } function renderPostProcess() { gl.enable(gl.TEXTURE_2D); gl.disable(gl.DEPTH_TEST); var bindRT = function (rt, isclear) { gl.bindFramebuffer(gl.FRAMEBUFFER, rt.frameBuffer); gl.viewport(0, 0, rt.width, rt.height); if(isclear) { gl.clearColor(0, 0, 0, 0); gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); } }; //make bright buff bindRT(renderSpec.wHalfRT0, true); useEffect(effectLib.mkBrightBuf, renderSpec.mainRT); drawEffect(effectLib.mkBrightBuf); unuseEffect(effectLib.mkBrightBuf); // make bloom for(var i = 0; i < 2; i++) { var p = 1.5 + 1 * i; var s = 2.0 + 1 * i; bindRT(renderSpec.wHalfRT1, true); useEffect(effectLib.dirBlur, renderSpec.wHalfRT0); gl.uniform4f(effectLib.dirBlur.program.uniforms.uBlurDir, p, 0.0, s, 0.0); drawEffect(effectLib.dirBlur); unuseEffect(effectLib.dirBlur); bindRT(renderSpec.wHalfRT0, true); useEffect(effectLib.dirBlur, renderSpec.wHalfRT1); gl.uniform4f(effectLib.dirBlur.program.uniforms.uBlurDir, 0.0, p, 0.0, s); drawEffect(effectLib.dirBlur); unuseEffect(effectLib.dirBlur); } //display gl.bindFramebuffer(gl.FRAMEBUFFER, null); gl.viewport(0, 0, renderSpec.width, renderSpec.height); gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); useEffect(effectLib.finalComp, renderSpec.mainRT); gl.uniform1i(effectLib.finalComp.program.uniforms.uBloom, 1); gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, renderSpec.wHalfRT0.texture); drawEffect(effectLib.finalComp); unuseEffect(effectLib.finalComp); gl.enable(gl.DEPTH_TEST); } ///// var SceneEnv = {}; function createScene() { createEffectLib(); createBackground(); createPointFlowers(); createPostProcess(); sceneStandBy = true; } function initScene() { initBackground(); initPointFlowers(); initPostProcess(); //camera.position.z = 17.320508; camera.position.z = pointFlower.area.z + projection.nearfar[0]; projection.angle = Math.atan2(pointFlower.area.y, camera.position.z + pointFlower.area.z) * 180.0 / Math.PI * 2.0; Matrix44.loadProjection(projection.matrix, renderSpec.aspect, projection.angle, projection.nearfar[0], projection.nearfar[1]); } function renderScene() { //draw Matrix44.loadLookAt(camera.matrix, camera.position, camera.lookat, camera.up); gl.enable(gl.DEPTH_TEST); //gl.bindFramebuffer(gl.FRAMEBUFFER, null); gl.bindFramebuffer(gl.FRAMEBUFFER, renderSpec.mainRT.frameBuffer); gl.viewport(0, 0, renderSpec.mainRT.width, renderSpec.mainRT.height); gl.clearColor(0.005, 0, 0.05, 0); gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); renderBackground(); renderPointFlowers(); renderPostProcess(); } ///// function onResize(e) { makeCanvasFullScreen(document.getElementById(\"sakura\")); setViewports(); if(sceneStandBy) { initScene(); } } function setViewports() { renderSpec.setSize(gl.canvas.width, gl.canvas.height); gl.clearColor(0.2, 0.2, 0.5, 1.0); gl.viewport(0, 0, renderSpec.width, renderSpec.height); var rtfunc = function (rtname, rtw, rth) { var rt = renderSpec[rtname]; if(rt) deleteRenderTarget(rt); renderSpec[rtname] = createRenderTarget(rtw, rth); }; rtfunc('mainRT', renderSpec.width, renderSpec.height); rtfunc('wFullRT0', renderSpec.width, renderSpec.height); rtfunc('wFullRT1', renderSpec.width, renderSpec.height); rtfunc('wHalfRT0', renderSpec.halfWidth, renderSpec.halfHeight); rtfunc('wHalfRT1', renderSpec.halfWidth, renderSpec.halfHeight); } function render() { renderScene(); } var animating = true; function toggleAnimation(elm) { animating ^= true; if(animating) animate(); if(elm) { elm.innerHTML = animating? \"Stop\":\"Start\"; } } function stepAnimation() { if(!animating) animate(); } function animate() { var curdate = new Date(); timeInfo.elapsed = (curdate - timeInfo.start) / 1000.0; timeInfo.delta = (curdate - timeInfo.prev) / 1000.0; timeInfo.prev = curdate; if(animating) requestAnimationFrame(animate); render(); } function makeCanvasFullScreen(canvas) { var b = document.body; var d = document.documentElement; fullw = Math.max(b.clientWidth , b.scrollWidth, d.scrollWidth, d.clientWidth); fullh = Math.max(b.clientHeight , b.scrollHeight, d.scrollHeight, d.clientHeight); canvas.width = fullw; canvas.height = fullh; } window.addEventListener('load', function(e) { var canvas = document.getElementById(\"sakura\"); try { makeCanvasFullScreen(canvas); gl = canvas.getContext('experimental-webgl'); } catch(e) { alert(\"WebGL not supported.\" + e); console.error(e); return; } window.addEventListener('resize', onResize); setViewports(); createScene(); initScene(); timeInfo.start = new Date(); timeInfo.prev = timeInfo.start; animate(); }); //set window.requestAnimationFrame (function (w, r) { w['r'+r] = w['r'+r] || w['webkitR'+r] || w['mozR'+r] || w['msR'+r] || w['oR'+r] || function(c){ w.setTimeout(c, 1000 / 60); }; })(window, 'equestAnimationFrame');"}],"posts":[{"title":"shell","slug":"shell","date":"2020-04-29T16:39:38.000Z","updated":"2020-04-29T16:43:26.321Z","comments":true,"path":"2020/04/30/shell/","link":"","permalink":"http://quincyper.github.io/2020/04/30/shell/","excerpt":"Chapter 4 shell编程 笔记 shell编程 简介： Shell是一种具备特殊功能的程序，是使用者和kernel间的一个接口 Shell 是一种功能强大的解释型编程语言 Shell 脚本语言非常擅长处理文本类型的数据","text":"Chapter 4 shell编程 笔记 shell编程 简介： Shell是一种具备特殊功能的程序，是使用者和kernel间的一个接口 Shell 是一种功能强大的解释型编程语言 Shell 脚本语言非常擅长处理文本类型的数据 规范： 以#!开头：表示系统用解释器执行此脚本 12#!/bin/bash#!/bin/ksh 以#注释： 通常注释包括 123456# 脚本名称# 脚本功能# 作者及联系方式# 版本更新记录# 版权声明# 对算法做简要说明（如果是复杂脚本） 执行： 方式1 ： source filename 或者 . filename 12source filename . filename 在当前shell环境下读取并执行 方式2 ： sh(或bash、ksh…) filename 1sh(或bash、ksh…) filename 新建一个子shell读取并执行filename中的命令 子shell继承父shell的环境变量，但子shell新建的、改变的变量不会被带回父shell 方式3 ： ./filename 1.&#x2F;filename 打开一个子shell来读取并执行filename中命令 子shell必须有可执行的权限 一、shell变量1. 变量的使用Shell编程中，使用变量无需事先声明 变量的赋值 1变量名=变量值 #（注意：不能留空格） 变量的引用 1$var #引用var变量 2. shell变量类型 1）用户自定义变量 有用户自己定义、修改和使用 shell的默认赋值是字符串赋值 1234var=1 var=$var+1 echo $var#打印的结果是var的地址值加一后的值 为了达到var的值加1的效果 通常有下面三种方式 1234567let \"var+=1\"var=$[$var+1]#前两种方式在bash下有效，在sh下会出错var=`expr $var + 1` #注意加号两边的空格 2）环境变量 Shell环境变量由系统维护，用于设置用户的Shell工作环境 只有少数的变量用户可以修改其值 在声明或赋值时使用export 123export 变量名export 变量名=变量值 使用export说明的变量，在Shell以后运行的所有命令或程序中都可以访问 子shell更改的环境变量并不会带回到父shell 常用的环境变量 意义 HOME 当前用户的主目录 PATH 用冒号分隔的目录路径名Shell将顺序搜索这些目录，找到的第一个与命令名称一致的可执行文件将被执行 TERM 终端的类型 HOSTNAME 主机名称 SHELL 当前使用的是哪种shell PWD 当前工作目录的绝对路径名，该变量的取值随cd命令的使用而变化 3） 位置参数变量 位置参数变量是一组特殊的内置变量 跟在脚本名后面的用空格隔开的字符串 12345$1 # 表示第1个参数值$9 # 表示第9个参数值$&#123;10&#125; # 表示第10个参数值$&#123;11&#125; # 表示第11个参数值 用途： 从shell命令/脚本的命令行接受参数 在调用shell 函数时为其传递参数 4） 专用参数变量 命令行参数相关 命令行参数相关 作用 $* 将所有位置参量看成一个字符串(以空格间隔) $@ 将每个位置参量看成单独的字符串(以空格间隔) $0 命令行上输入的Shell程序名 $# 表示命令行上参数的个数 进程状态相关 进程状态相关 作用 $? 表示上一条命令执行后的返回值 $$ 当前进程的进程号 $! 显示运行在后台的最后一个作业的 PID $? 返回状态 $? 返回值 状态 0 成功 1-255 不成功 1 通用错误 126 命令或脚本没有执行权限 127 命令没有找到 二、shell常用内置命令1.常规常用命令 echo | 显示 在屏幕上显示出由 arg 指定的字串 12# 命令格式echo arg export | 变量赋值 1234# 命令格式export 变量[=变量值]export shell可以用export把他的变量向下带入子shell，从而让子进程继承父进程中的环境变量 不带任何变量名的export语句将显示出当前所有的export变量 eval| 执行表达式 对参数进行两次扫描和替换 将所有的参数连接成一个表达式，并计算或者执行该表达式 参数中的任何变量都将被展开 12345678# 示例listpage=\"ls -l | more\"eval $listpageeval $(ssh-agent)eval newstr=\\$$str2eval echo \\$$&#123;x&#125;_URL 123456789# 思考以下三组命令的区别myfile=“cat file1.txt” echo $myfilemyfile=“cat file1.txt” eval echo $myfile myfile=“cat file1.txt” eval $myfile read| 键盘输入赋值 从键盘输入内容为变量赋值 12# 命令格式read -p \"信息\" [var1 var2 ...] 123# 示例read -p \"Enter you name:\"echo \"I know your name is $REPLY\" 若省略变量名，则将输出的内容默认存入RELPLY变量中 readonly | 只读的变量赋值 不能被清除或重新赋值的变量 12# 命令格式readonly variable 12345678# 示例echo -e \"What is your name? \\c\"read nameecho \"Hello $name\"readonly nameecho -e \"What is your another name? \\c\"read nameecho \"Oh $name\" 2.重要编程命令 shift|左移 12# 命令格式shift [n] 将位置参量列表依次左移n次（缺省为左移一次） 一旦位置参量列表被移动，最左端的那个参数就会从列表中删除 经常与循环结构语句一起使用，以便遍历每一个位置参数 123456789101112131415# 示例#!/bin/#!/bin/shsh# ScriptName: pp_s_shift.shsh# To test Positional Pararameters &amp; Shift.echo \"The script name is: $0\"echo '$1'=$1,'$2'=$2,'$3'=$3,'$4'=$4 -- '$#'=\"$#\"echo '$@': \"$@\"shitf # 向左移动所有的位置1次echo '$1'=$1,'$2'=$2,'$3'=$3,'$4'=$4 -- '$#'=\"$#\"echo '$@': \"$@\"shitf 2 # 向左移动所有的位置2次echo '$1'=$1,'$2'=$2,'$3'=$3,'$4'=$4 -- '$#'=\"$#\"echo '$@': \"$@\"$./pp_shift.sh 1 b 3 d 5 f declare | 声明变量 内置命令 declare 可用来声明变量 1declare [选项] variable[=value] 选项 含义 -r 将变量设为只读( readonly ) -x 将变量输出到子shell 中（export 为全局变量） -i 将变量设为整型( integer ) -a 将变量设置为一个数组( array ) -f 列出函数的名字和定义( function ) -F 只列出函数名 12345678910111213# 示例declare myname=lbwdeclare -r myname=lbwunset mynamedeclare mynanme=\"lbw NB\"declare -x myname2=mafeifeimyname2=mafeifeideclare -x myname2declare 3.数字运算相关命令 let | 算术运算 expr | 通用的表达式计算 printf | 按照指定格式输出 在之后的整数运算中对运算相关的内置命令会详细介绍 4.退出与读入 exit|退出 退出脚本或当前shell 12# 示例exit n n 是一个 0-255 的整数 0 表示成功退出，非零表示遇到某种失败 返回值 被保存在状态变量$?中 .(点) | 读入 使Shell读入指定的Shell程序文件并依次执行文件中的所有语句 12# 示例. Shell程序文件名 三、特殊字符1.一般通配符可以同时使用多个通配符 一般通配符 功能 备注 * 匹配不限长度的多个字符 ? 匹配任意一个字符 [] 匹配字符组所限定的任何一个字符 ▪ 字符组可以由直接给出的字符组成，也可以由字符和连字符(-)组成▪ f[a-d]与f[abcd]作用相同 ! 表示不在方括号中所列出的字符 f[!1-9].c 表示以f打头，后面一个字符不是数字1至9的.c文件名，它匹配fa.c、fb.c、fm.c等 2.模式表达式bash除支持一般通配符外，还提供扩展模式匹配表达式 模式表达式 作用 示例 *(模式表) 匹配给定模式表中 “模式” 的0次或多次出现，各模式之间以 “ | ” 分开 file*(.c|.o)将匹配文件file、file.c、file.o、file.c.c、file.o.o、file.c.o、file.o.c等 +(模式表) 匹配给定模式表中 “模式” 的1次或多次出现，各模式之间以 “ | ” 分开 file(.c|.o)将匹配ile.c、file.o、file.c.o、file.c.c等。*但不匹配file**。 ?(模式表) 匹配模式表中 任何一种“模式” 的0次或1次出现，各模式之间以“ |”分开 file?(.c|.o)匹配file、file.c和file.o，不匹配file. c. c、file. c.o等。 @(模式表) 匹配模式表中 给定“模式” 的1次出现，各模式之间以“|”分开 file@(.c|.0)只匹配file.c和file.o !(模式表) 除给定模式表中的一个“模式”之外，它可以匹配其它任何东西 3.引号Shell中引号有3种：单引号、双引号和倒引号。 双引号 如果在赋给变量的值中要含有空格、制表符或换行符，要用双引号 1names=\"Zhangsan Lisi Wangwu\" 在双引号内除 $ ，` ， \\ 仍保留其特殊功能外，其余字符均作为普通字符对待。 $ 表示变量替换 ` 倒引号表示命令替换 \\ 为转义字符 1echo “Dir is `pwd` and logname is $LOGNAME” 单引号 由单引号括起来的字符都作为普通字符出现，即使是$，`，\\ 123echo ' The time is ` date ` , the file is $HOME/abc 'The time is ` date ` , the file is $HOME/abc 倒引号 倒引号括起来的字符串被shell解释为命令行，在执行时，Shell会先执行该命令行，并以它的标准输出结果取代整个倒引号部分。 1234echo “current directory is ` pwd `”# 结果显示current directory is /home/mengqc 因此倒引号有命令替换的作用，可以将一个命令的执行结果赋值给变量。 命令替换一共有两种形式：倒引号、$ ` 命令表 ` 12# 将当前工作目录的全路径名存放到变量dir中dir=`pwd` $(命令表) 12345# 将当前工作目录的全路径名存放到变量dir中dir=$(pwd) #注意#shell中不能随意添加和去掉括号 4.括号 括号类型 作用 () 1.命令组2.结合$进行命令替换3.初始化数组array=(a b c d) [] 1.字符范围2.数组编号3.算术运算4.条件判断 {} 替换 ( () ) 1.算术运算2.for循环中的算术运算比较for((i=0;i&lt;5;i++)) [ [] ] 条件判断等 5. 特殊字符的组合使用在实际运用中 假如我们想把 str1中的字符串复制到 str2中，然后用str2来显示，那么直接使用用以下的方法是不能成功的 123456789# 案例1# 把 str1中的字符串复制到 str2中# 显示str2中的值str1=\"Hello World\"str2=str1echo $str2# 结果展示：str1 因此我们得需要使用一定的符号与其他符号相结合对变量进行间接的引用，这样才能达到案例中想要得到的效果。这样的方法我们称之为变量的间接引用 。 123456789101112131415# 实例1-1# 通过 str2的值来引用 str1的值# bash2.0以上才支持str1=\"Hello World\"str2=str1newstr=$&#123;!str2&#125; echo $newstr # 方法1echo \" 1 \"echo $&#123;!str2&#125; # 方法2# 结果展示：Hello World 1 Hello World 12345678910111213# 实例1-2# 通过 str2的值来引用 str1的值# bash都支持eval newstr=\\$$str2 echo $newstrHello World # 方法1echo \" 1 \"eval echo \\$$str2 # 方法2# 结果展示：Hello World 1 Hello World 12345678910111213# 实例2-1# 通过 x的值来引用 CENTOS_URL的值# bash2.0以上才支持x=\"CENTOS\" CENTOS_URL=\"http://mirrors.163.com/centos/\"newstr=$&#123;x&#125;_URLecho $newstrecho $&#123;!newstr&#125;# 结果展示：CENTOS_URLhttp://mirrors.163.com/centos/ 123456789101112# 实例2-2# 通过 x的值来引用 CENTOS_URL的值# bash都支持x=\"CENTOS\" CENTOS_URL=\"http://mirrors.163.com/centos/\"eval newstr=\\$$&#123;x&#125;_URL # 方法1echo $newstreval echo \\$$&#123;x&#125;_URL # 方法2# 结果展示：http://mirrors.163.com/centos/http://mirrors.163.com/centos/ 四、整数运算1.定义 bash上的变量没有严格的类型定义，本质上bash变量都是字符串。 若一个字面常量或变量的值是纯数字的（不包含字母或其他字符），bash可以将其当作长整型值，并可做算术运算和比较运算。 bash允许显式地声明整型变量 1declare -i 变量名 常见的算术运算符： 运算方式 运算符号 四则运算 +、 -、 *、 / 幂运算、模运算、取余 **、 % 按位左移、按位右移 &lt;&lt;、 &gt;&gt; 按位与、按位异或、按位或 &amp;、 ^、 赋值运算 =、 +=、 -= 、 *=、 /= 、 %=、 &lt;&lt;= 、 &gt;&gt;= 、 &amp;=、 ^=、|= 比较操作符 &lt;、 &gt;、 &lt;=、 &gt;=、 ==、 != 逻辑与、逻辑或 &amp;&amp;、|| 注：按位运算是以二进制形式进行的。 2.$[] 运算拓展用 $[···]，$((···))进行整数运算时，括号内变量前的美元符号 $可以省略。 123$[expression]#等同于$((expression)) 感受${...} $(...) $[...] $((...))的不同作用 123# 示例 1num1=$[4+1]; echo $num1num1=$(($num1*2-3)); echo $num1 1234# 示例 2((num2=2+3**2-1001%5)); echo $num2num2=$((2+3**2-1001%5)); echo $num2echo $((2+3**2-1001%5)) 3.运算相关内置命令 let | 算术运算 let 内置命令用于算术运算 复制符号和运算符两边不能留空格 如果将字符串复制给一个整型变量时，变量的值为0 如果变量的值是字符串，则进行算术运算时设为0 将let后的语句放在引号内，则可忽略空格的特殊含义 1234567# 示例num2=1;echo $num2let num2=4+1;echo $num2let num2=$num2+1;echo $num2# 用引号忽略空格的特殊含义let \"num2=4 + 1\" 注： 用let命令进行算术运算时，最好加双引号 expr | 表达式计算 通用的表达式计算命令 表达式中参数与操作符必须以空格分开 表达式中的运算可以是算术运算，比较运算，字符串运算和逻辑运算 乘法符号和括号需要被转义 12345# 示例expr 5 % 3expr 5 \\* 3 #乘法符号必须被转义expr 2 + 5 \\* 2 - 3 % 2expr \\( 2 + 5 \\) \\* 2 - 3 #括号必须被转义 printf | 格式输出 printf可用来按指定的格式输出变量 1printf format 输出参数列表 格式说明符 格式说明符 类型 格式说明符 类型 c 字符型 g/G 浮点数（自动） d 十进制整数 o 八进制 e/E 浮点数（科学计数法） s 字符串 f 浮点数（小数形式） x/X 十六进制 末尾可添加的拓展 符号 作用 符号 作用 \\a 警铃 \\t 水平制表符 \\b 退后一格 \\v 垂直制表符 \\n 换行 \\ \\ 反斜杠 \\f 换页 \\ “ 双引号 \\r 回车 %% 百分号 12345# 示例printf \"The number is: %.2f\\n\" 100printf \"%-20s|%12.5f|\\n\" \"Joy\" 10printf \"%-10x%010o%+10d\\n\" 20 20 20printf \"%6d\\t%6o\\\"%6x\\\"\\n\" 20 20 20 4.数组变量Bash2.X 以上支持一位数组，下标从0开始。 数组赋值 使用declare 声明（declare详细使用请看 二、shell常用内置命令2.重要编程命令） 直接给变量名加下标 1234567# 使用decare声明declare -a varvar=（item1 item2 item3 ...）#直接给变量名加下标var=（item1 item2 item3 ...）var[n]=value 数组引用 1$&#123;variable[n]&#125; 123456# 示例declare -a stustu=(math1 math2 math3)echo $&#123;stu[0]&#125; # 列出stu的第一个元素echo $&#123;stu[*]&#125; # 列出stu的所有元素echo $&#123;#stu[*]&#125; # 给出数组stu中的个数 数组与数组元素的删除 123# 示例unset stu[0] # 删除stu的第一个元素unset stu # 删除整个数组 数组赋值无须按顺序 123# 示例：x[3]=100;echo $&#123;x[*]&#125;state=(ME [3]=CA [2]=NT);echo $&#123;state[*]&#125; 五、条件测试1.定义条件测试可以判断某个特定条件是否满足 条件测试的种类 命令 成功 | 失败 表达式 真 | 假 条件测试的值 Bash中没有布尔类型变量，因此 退出状态为0 ：表示 命令成功 或 表达式为真 退出状态非0：表示 命令失败 或 表达式为假 状态变量$?中保存了退出状态的值 12345678# 示例Host=centos1ping -c 1 $Hostecho $?ping -c 1 $Host &gt; /dev/null \\ &amp;&amp; echo \"$Host is up.\" \\ || echo \"$Host is down.\" 条件测试语句 语句格式 格式1： 1test 测试表达式 格式2： 1[ 测试表达式 ] 格式3： 1[[ 测试表达式 ]] # （Bash2.X以上版本） 语句注意： 格式1 和 格式2 是等价的，格式3是扩展的 test 命令 在 [[ ]] 中可以使用通配符进行模式匹配 &amp;&amp;, ||, &lt;, 和&gt;能够正常存在于[[ ]]中，但不能在[] 中出现 [ 和 [[ 之后的字符必须为空格，]和]]之前的字符必须为空格 要对整数进行关系运算也可以使用 (( )) 进行测试 2.条件测试操作符 文件测试操作符 测试文件是否存在，文件属性，访问权限等 操作符 作用 [ -f fname ] fname存在且是普通文件时，返回真( 即返回0) [ -L fname ] fname存在且是链接文件时，返回真 [ -d fname ] fname存在且是一个目录时，返回真 [ -e fname ] fname（文件或目录）存在时，返回真 [ -s fname ] fname存在且大小大于0时，返回真 [ -r fname ] fname（文件或目录）存在且可读时，返回真 [ -w fname ] fname（文件或目录）存在且可写时，返回真 [ -x fname ] fname（文件或目录）存在且可执行时，返回真 更多文件测试符参见test的在线帮助，输入命令man test 字符串测试操作符 字符串安从左到右对应字符的ASCII码进行比较 操作符 作用 [ -z string ] 如果字符串string长度为0，返回真 [ -n string ] 如果字符串string长度不为0，返回真 [ str1 = str2 ] 两字符串相等（也可使用 == ）返回真 [ str1 != str2 ] 两字符串不等返回真 [[ str1 == str2 ]] 两字符串相同返回真 [[ str1 != str2 ]] 两字符串不相同返回真 [[ str1 =~ str2 ]] str2是str1的子串返回真 [[ str1 &gt; str2 ]] str1大于str2返回真 [[ str1 &lt; str2 ]] str1小于str2返回真 检查空值 1234[ \"$name\" = \"\" ][ -z \"$name\" ][ ! \"$name\" ][ \"X$&#123;name&#125;\" = \"X\" ] 检查非空值 1234[ \"$name\" != \"\" ][ -n \"$name\" ][ \"$name\" ][ \"X$&#123;name&#125;\" != \"X\" ] 整数二元比较操作符 整数测试主要是两个整数比较大小关系 等于eq（equal ） 大于gt（greater） 小于lt（little） 操作符两边必须留空格的情况 字母需要中括号 操作符 作用 [ int1 -eq int2 ] int1 等于 int2 返回真 [ int1 -ne int2 ] int1 不等于 int2 返回真 [ int1 -gt int2 ] int1 大于 int2 返回真 [ int1 -ge int2 ] int1 大于或等于 int2 返回真 [ int1 -lt int2 ] int1 小于 int2 返回真 [ int1 -le int2 ] int1 小于或等于 int2 返回真 操作符 作用 [ [ int1 -eq int2 ] ] int1 等于 int2 返回真 [ [ int1 -ne int2 ] ] int1 不等于 int2 返回真 [ [ int1 -gt int2 ] ] int1 大于 int2 返回真 [ [ int1 -ge int2 ] ] int1 大于或等于 int2 返回真 [ [ int1 -lt int2 ] ] int1 小于 int2 返回真 [ [ int1 -le int2 ] ] int1 小于或等于 int2 返回真 操作符两边空格可省略的情况 符号需要小括号 操作符 作用 ( ( int1 == int2 ) ) int1 等于 int2 返回真 ( ( int1 != int2 ) ) int1 不等于 int2 返回真 ( ( int1 &gt; int2 ) ) int1 大于 int2 返回真 ( ( int1 &gt;= int2 ) ) int1 大于或等于 int2 返回真 ( ( int1 &lt; int2 ) ) int1 小于 int2 返回真 ( ( int1 &lt;= int2 ) ) int1 小于或等于 int2 返回真 12345678# 示例a=linux ; b=unixn=5 ; m=7[ $a != $b ] ; echo $?0[[ $a != $b ]] ;0 逻辑运算符 与 a &amp;&amp; 或 o || 非！ 符号 作用 [ expr1 -a expr2 ] 逻辑与，都为真时，结果为真 [ expr1 -o expr2 ] 逻辑或，有一个为真时，结果为真 [ ! expr ] 逻辑非 符号 作用 [ [ expr1 &amp;&amp; expr2 ] ] 逻辑与，都为真时，结果为真 [ [ expr1 || expr2 ] ] 逻辑或，有一个为真时，结果为真 [ [ ! expr ] ] 逻辑非 符号 作用 ( ( expr1 &amp;&amp; expr2 ) ) 逻辑与，都为真时，结果为真 ( ( expr1 || expr2 ) ) 逻辑或，有一个为真时，结果为真 ( ( ! expr ) ) 逻辑非 注意： 不能随便添加括号 不能在 (( )) 中做字符串比较 &amp;&amp; 有时候是做命令聚合 而不是逻辑运算 1# 案例 六、流程控制 分支 if 条件语句 case 选择语句 循环 for 循环语句 while 循环语句 until 循环语句 select 循环与菜单 1.分支结构 | if 语句语法 if 语法结构 12345678910if expr1 # 如果 expr1 为真(返回值为0)then # 那么 commands1 # 执行语句块 commands1elif expr2 # 若 expr1 不真，而 expr2 为真then # 那么 commands2 # 执行语句块 commands2 ... ... # 可以有多个 elif 语句else # else 最多只能有一个 commands4 # 执行语句块 commands4fi # if 语句必须以单词 fi 终止 实际案例 2.分支结构 | case 语句语法 case 语法结构 123456789101112case expr in # expr为表达式，关键词 in不要忘！ pattern1) # 若 expr与 pattern1匹配，注意括号 commands1 # 执行语句块 commands1 ;; # 跳出 case结构 pattern2) commands2 ;; ... ... # 可以有任意多个模式匹配 *) # 若 expr与上面的模式都不匹配 commands # 执行语句块 commands ;; # 跳出 case结构esac # case语句必须以 esac终止 表达式 expr 按顺序匹配每个模式，一旦有一个模式匹配成功，则执行该模式后面的所有命令，然后退出 case。 如果 expr没有找到匹配的模式，则执行缺省值 “ *) ” 后面的命令块 ( 类似于 if 中的 else)； “ *)” 可以不出现。 所给的匹配模式 pattern中可以含有通配符和“ |”。 每个命令块的最后必须有一个双分号，可以独占一行，或放在最后一个命令的后面。 实际案例 3.循环结构 | for 语法 foreach 型 语法 1234for variable in list # 每一次循环，依次把列表 list中的一个值赋给循环变量do # 循环体开始的标志 commands # 循环变量每取一次值，循环体就执行一遍done # 循环结束的标志，返回循环顶部 说明 列表 list可以是命令替换、变量名替换、字符串和文件名列表 ( 可包含通配符 )，每个列表项以空格间隔 for循环执行的次数取决于列表 list中单词的个数 可以省略 in list，省略时相当于 in &quot;$@&quot; 实际案例 break和continue break 1break [n] 用于强行退出当前循环。 如果是嵌套循环，则 break命令后面可以跟一数字 n，表示退出第 n重循环（最里面的为第一重循环）。 continue 1continue [n] 用于忽略本次循环的剩余部分，回到循环的顶部，继续下一次循环。 如果是嵌套循环，continue命令后面也可跟一数字n，表示回到第 n重循环的顶部。 实际案例 c语言型 语法 1234for ((expr1;expr2;expr3)) # 执行 expr1do # 若 expr2的值为真时进入循环，否则退出 for循环commands # 执行循环体，之后执行 expr3done # 循环结束的标志，返回循环顶部 说明 通常 expr1和 expr3是算数表达式； expr2是逻辑表达式 expr1仅在循环开始之初执行一次 expr2在每次执行循环体之前执行一次 expr3 在每次执行循环体之后执行一次 实际案例 4.循环结构| while、 until 循环语法 while 语法 1234while expr # 执行 exprdo # 若expr的退出状态为0，进入循环，否则退出while commands # 循环体done # 循环结束标志，返回循环顶部 ubtil 语法 1234until expr # 执行 exprdo # 若expr的退出状态非0，进入循环，否则退出until commands # 循环体done # 循环结束标志，返回循环顶部 实际案例 while / untile /for 循环案例 5.循环结构 | select语法 语法 1234select variable in listdo # 循环开始的标志 commands # 循环变量每取一次值，循环体就执行一遍done # 循环结束的标志 说明 按数值顺序排列的菜单项（listitem）会显示到标准错误 菜单项的间隔符由环境变量 IFS 决定 用于引导用户输入的提示信息存放在环境变量 PS3 中 用户输入的值会被存储在内置变量 RELAY 中 用户直接输入回车将重新显示菜单 与 for循环类似，省略 in list时等价于 in “$*” 实际案例 七、参数控制在脚本中经常使用流程控制处理位置参数 循环结构： while for 多分枝结构：case 脚本中经常使用如下命令配合位置参数处理 shift getopts 八、shell函数1.定义 Shell函数就是一个子程序，用于完成特定任务。 例如，添加一个用户、判断用户是否为管理员的等 函数㐉之后可以被用它 的主程序调用 调用函数的方法和执行Shell命令一样 可以在Shell脚本中直接调用（函数需先定义） 也可在命令行上直接调用（定义函数的文件需先加载） 函数定义 123456789# 函数定义 1function 函数名 &#123; commands&#125;# 函数定义 2函数名()&#123; commands&#125; 函数调用 只需输入函数名即可调用函数 函数必须在调用之前定义 12345# 函数调用 1函数名# 函数调用 2函数名 参数1 参数2 .... 实际案例分析： 2.函数的存储方式 函数和调用它的主程序保存在同一个文件中 函数的定义必须出现在调用之前 函数和调用它的主程序保存在不同的文件中 主程序必须先使用 source 被调用函数的文件 3.函数的显示 显示当前Shell可见的所有函数名 1declare -F 显示当前Shell可见的所有（或指定）的函数定义 12declare -fdeclare -f &lt;functionName&gt; 4.函数的参数与变量 参数 调用参数时，使用位置参数的形式为函数传递参数 函数内的$1-${n} $*和 $@将被重置为调用函数之前的值 在主程序和函数中，$0始终代表脚本名 变量 函数内使用 local声明变量是局部变量 局部变量的作用域是当前函数以及其调用的所有函数 函数内未使用local声明变量是全局变量 主程序和函数中的同名变量是一个变量（地址一致） 实际案例分析： 5.函数的结束与返回值 当函数的最后一条命令执行结束函数即结束 函数的返回值就是最后一条命令的退出码 其返回值被保存在系统变量$?中 可以使用 return 或 exit 显式地结束函数 return [N] return 将结束函数的执行 可以使用 N 指定函数返回值 exit [N] exit 将中断当前函数及当前Shell的执行 可以使用 N 指定返回值 注意： 使用全局变量引用函数的值 不利于结构化编程 使用return和exit只能返回整数值 实际案例分析; 使用标准输出实现函数的返回值 是一种通用的方法，既能返回整数又能返回字符串 函数结束前使用echo 命令将结果显示到标准输出 调用函数时使用如下的格式将函数的输出结果存到变量RES 中，之后便可使用变量$RES 的值（或输出、或执行测试、或进一步处理等） 12RES=$(functionName)echo $RES 实际案例分析： 课后习题 写shell程序，从键盘输入一个数字，判断其为奇数还是偶数 写shell程序，输入一个数字，计算阶乘 写shell程序，获取当前用户名、ip地址","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://quincyper.github.io/tags/Linux/"}]},{"title":"搭建测试","slug":"博客搭建测试","date":"2019-12-11T16:00:00.000Z","updated":"2020-04-29T04:03:41.488Z","comments":true,"path":"2019/12/12/博客搭建测试/","link":"","permalink":"http://quincyper.github.io/2019/12/12/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%B5%8B%E8%AF%95/","excerpt":"此篇为测试，如若符合要求后期会自动删除","text":"此篇为测试，如若符合要求后期会自动删除 创建一篇新文章1$ hexo new \"博客搭建测试\" 有一说一 qzp牛逼 本地查看静态网页1$ hexo server 我宣布 现在这里称之为qzp广场 全体起立 qzp牛逼 上传网页同步1$ hexo deploy 奥里给！qzp牛批！qzp牛批！qzp牛批！qzp牛批！qzp牛批！qzp牛批！qzp牛批！","categories":[{"name":"测试类","slug":"测试类","permalink":"http://quincyper.github.io/categories/%E6%B5%8B%E8%AF%95%E7%B1%BB/"}],"tags":[{"name":"test","slug":"test","permalink":"http://quincyper.github.io/tags/test/"}]}]}